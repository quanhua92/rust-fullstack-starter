name: Release

on:
  push:
    tags:
      - 'v*'

env:
  CARGO_TERM_COLOR: always
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  validate-tag:
    name: Validate Release Tag
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.tag.outputs.version }}
      is_prerelease: ${{ steps.tag.outputs.prerelease }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Validate tag format
      id: tag
      run: |
        TAG=${GITHUB_REF#refs/tags/}
        echo "Tag: $TAG"
        
        # Check if tag matches semantic versioning
        if [[ $TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)(-[a-zA-Z0-9\-\.]+)?(\+[a-zA-Z0-9\-\.]+)?$ ]]; then
          VERSION=${TAG#v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Check if it's a prerelease (contains - in version)
          if [[ $TAG =~ ^v[0-9]+\.[0-9]+\.[0-9]+-.+ ]]; then
            echo "prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "prerelease=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ùå Invalid tag format. Expected: v1.2.3 or v1.2.3-alpha.1"
          exit 1
        fi

  test:
    name: Test Suite
    runs-on: ubuntu-latest
    needs: [validate-tag]
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    env:
      STARTER__DATABASE__HOST: localhost
      STARTER__DATABASE__PORT: 5432
      STARTER__DATABASE__USER: test_user
      STARTER__DATABASE__PASSWORD: test_password
      STARTER__DATABASE__DATABASE: test_db
      STARTER__DATABASE__MAX_CONNECTIONS: 5
      STARTER__DATABASE__MIN_CONNECTIONS: 1
      STARTER__SERVER__HOST: 127.0.0.1
      STARTER__SERVER__PORT: 8080
      STARTER__AUTH__SESSION_DURATION_HOURS: 24
      STARTER__AUTH__CLEANUP_INTERVAL_SECS: 3600
      STARTER__WORKER__CONCURRENCY: 2
      STARTER__WORKER__POLL_INTERVAL_SECS: 1
      STARTER__WORKER__MAX_RETRIES: 3
      STARTER__WORKER__RETRY_BACKOFF_BASE_SECS: 1
      RUST_LOG: info
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy

    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      with:
        workspaces: starter

    - name: Install sqlx-cli
      run: cargo install sqlx-cli --no-default-features --features postgres

    - name: Run database migrations
      run: |
        cd starter
        sqlx migrate run --database-url postgresql://test_user:test_password@localhost:5432/test_db

    - name: Run full test suite
      run: cargo test --manifest-path starter/Cargo.toml --all-targets --all-features

    - name: Run clippy with strict settings
      run: cargo clippy --manifest-path starter/Cargo.toml --all-targets --all-features -- -D warnings -D clippy::all

    - name: Check formatting
      run: cargo fmt --manifest-path starter/Cargo.toml --all -- --check

  security:
    name: Security Checks
    runs-on: ubuntu-latest
    needs: [validate-tag]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      with:
        workspaces: starter

    - name: Install security tools
      run: |
        cargo install cargo-audit --locked
        cargo install cargo-deny --locked

    - name: Run security audit
      run: cargo audit --db-urls https://github.com/RustSec/advisory-db.git

    - name: Run dependency checks
      run: cargo deny --manifest-path starter/Cargo.toml check

  build-release:
    name: Build Release Images
    runs-on: ubuntu-latest
    needs: [validate-tag, test, security]
    
    permissions:
      contents: read
      packages: write
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=sha,prefix={{branch}}-

    - name: Build and push release image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.prod
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-tag, test, security, build-release]
    
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate changelog
      id: changelog
      run: |
        # Get the previous tag
        PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -2 | tail -1)
        CURRENT_TAG=${GITHUB_REF#refs/tags/}
        
        echo "Generating changelog from $PREVIOUS_TAG to $CURRENT_TAG"
        
        # Generate changelog using git log
        CHANGELOG=$(git log --pretty=format:"- %s (%h)" $PREVIOUS_TAG..$CURRENT_TAG --no-merges)
        
        # Create multiline output
        {
          echo "changelog<<EOF"
          echo "## What's Changed"
          echo ""
          if [ -n "$CHANGELOG" ]; then
            echo "$CHANGELOG"
          else
            echo "- Initial release"
          fi
          echo ""
          echo "## Container Images"
          echo ""
          echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-tag.outputs.version }}\`"
          echo ""
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...$CURRENT_TAG"
          echo "EOF"
        } >> $GITHUB_OUTPUT

    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref_name }}
        release_name: Release ${{ github.ref_name }}
        body: ${{ steps.changelog.outputs.changelog }}
        draft: false
        prerelease: ${{ needs.validate-tag.outputs.is_prerelease }}

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate-tag, create-release]
    if: needs.validate-tag.outputs.is_prerelease == 'false'
    environment: 
      name: production
      url: https://your-domain.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to production
      run: |
        echo "üöÄ Deploying version ${{ needs.validate-tag.outputs.version }} to production"
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-tag.outputs.version }}"
        
        # Example deployment commands:
        # kubectl set image deployment/starter-app starter-app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-tag.outputs.version }}
        # helm upgrade starter-app ./helm/starter --set image.tag=${{ needs.validate-tag.outputs.version }}
        # docker-compose pull && docker-compose up -d
        
        echo "‚úÖ Production deployment completed"

  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [validate-tag, create-release, deploy-production]
    if: always()
    
    steps:
    - name: Notify success
      if: needs.create-release.result == 'success'
      run: |
        echo "üéâ Release ${{ github.ref_name }} created successfully!"
        echo "üê≥ Container image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-tag.outputs.version }}"
        
        if [ "${{ needs.validate-tag.outputs.is_prerelease }}" == "false" ]; then
          echo "üöÄ Production deployment: ${{ needs.deploy-production.result }}"
        else
          echo "üß™ Pre-release - no production deployment"
        fi
        
        # Add your notification logic here:
        # - Slack webhook
        # - Discord webhook
        # - Email notification
        # - Teams notification

    - name: Notify failure
      if: needs.create-release.result == 'failure' || needs.deploy-production.result == 'failure'
      run: |
        echo "‚ùå Release ${{ github.ref_name }} failed!"
        echo "Create Release: ${{ needs.create-release.result }}"
        echo "Deploy Production: ${{ needs.deploy-production.result }}"
        
        # Add your failure notification logic here